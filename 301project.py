# -*- coding: utf-8 -*-
"""301Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1naEVd3mWl2uMq13djdqWbPeLqdmPLKCI
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import mean_squared_error
from sklearn.pipeline import make_pipeline
from sklearn.metrics import mean_squared_error

abnb = pd.read_csv('/content/drive/MyDrive/Data301Project/NYCAirBNB/AB_NYC_2019.csv')
raw_abnb = pd.read_csv('/content/drive/MyDrive/Data301Project/NYCAirBNB/AB_NYC_2019.csv')

abnb = abnb.drop(columns=['id', 'name', 'host_id', 'host_name', 'last_review'])

# ensure that only reviews_per_month contains NaN
for attr in abnb:
  nulls = abnb[attr].isnull()
  for null in nulls:
    if null == True and attr != 'reviews_per_month':
      print(attr)

abnb = abnb.fillna(0)

abnb = abnb.query('neighbourhood_group == "Manhattan"')

prices = abnb['price']
abnb = abnb.drop(columns=['price', 'neighbourhood_group'])

abnb['neighbourhood'] = abnb['neighbourhood'].astype('category')
abnb['neighbourhood'] = abnb['neighbourhood'].cat.codes

abnb['room_type'] = abnb['room_type'].astype('category')
abnb['room_type'] = abnb['room_type'].cat.codes

X_train, X_test, Y_train, Y_test = train_test_split(abnb, prices, train_size=0.80, random_state=5)

correlated = X_train.apply(lambda x: x.corr(Y_train)).sort_values()
correlatedabs = abs(correlated).sort_values(ascending = False)
variables = correlated.index

# reduce df to only the variables that are correlated:

for attr in abnb:
  if(attr not in variables):
    abnb = abnb.drop(columns=[attr])
    X_train = X_train.drop(columns=[attr])
    X_test = X_test.drop(columns=[attr])

def normalize(df, columns):
    result = df[columns]
    result = (result - result.mean())/result.std()
    return result

for attr in variables:
  if correlated[attr] < 0:
    X_train[attr] = X_train[attr] * -1
    X_test[attr] = X_test[attr] * -1

X_train = normalize(X_train, variables)
X_test = normalize(X_test, variables)



split_size = int(len(X_train) * 0.1)
acc = []
for degree in range(1, 5):
  avgAcc = []
  print(degree)
  for split in range(split_size * 9, -1, split_size * -1):
    x_tr = X_train[0:split]
    y_tr = Y_train[0:split]
    x_ts = X_train[split:split + split_size]
    y_ts = Y_train[split:split + split_size]
    x_tr = np.vstack((x_tr, X_train[split + split_size:]))
    y_tr = pd.concat([y_tr, Y_train[split + split_size:]])
    poly_model = make_pipeline(PolynomialFeatures(degree, include_bias=False),LinearRegression(fit_intercept=True))
    poly_model.fit(x_tr, y_tr)
    y_pred = poly_model.predict(x_ts)
    avgAcc.append(mean_squared_error(y_ts, y_pred))
  acc.append(np.mean(avgAcc))
print(acc)

plt.plot(np.arange(1, 5), acc, '-o')
plt.show()

degree = np.argsort(acc)[0] + 1

# average distance of actual values from fitted model:
poly_model = make_pipeline(PolynomialFeatures(degree,include_bias=False),LinearRegression(fit_intercept=True))
poly_model.fit(X_train, Y_train)
predprices = poly_model.predict(X_test)
np.mean(np.abs(predprices - Y_test))

# adjusted r-squared value:
SS_Residual = sum((predprices)**2)       
SS_Total = sum((Y_test-np.mean(Y_test))**2)     
r_squared = 1 - (float(SS_Residual))/SS_Total
adjusted_r_squared = 1 - (1-r_squared)*(len(Y_test)-1)/(len(Y_test)-X_test.shape[1]-1)
print('R-Squared: {} \nAdj. R-Squared: {}'.format(r_squared, adjusted_r_squared))

# variable v price

plt.figure(figsize=(8, 12))

values = correlated.to_frame()
values = values.iloc[::-1]
heatmap2 = sns.heatmap(values, annot=True, cmap='crest')
heatmap2.set_xticklabels(['Price'])
heatmap2.set_yticklabels(variables)
heatmap2.set_title('Correlation of Variables With Price', fontdict={'fontsize':18}, pad=12)

# all variable heatmap

plt.figure(figsize=(12,8))
heatmap1 = sns.heatmap(raw_abnb.drop(columns=['id', 'host_id', 'name', 'host_name']).corr(), annot=True, cmap='crest')
heatmap1.set_title('Correlation Heatmap', fontdict={'fontsize':18}, pad=12)

plt.xticks(rotation=60)

# dataset visualizations

# total datapoints

plt.figure(figsize=(25,8))
raw_abnb.query('neighbourhood_group == "Manhattan"').groupby(['neighbourhood']).room_type.count().plot.bar(color='#69b3a2')
plt.xlabel('Neighbourhood', fontdict={'fontsize':12})
plt.ylabel('Total Observations', fontdict={'fontsize':12})
plt.xticks(rotation=45)
plt.title('Total Observations by  Manhattan Neighbourhood', fontdict={'fontsize':16}, pad=12)

plt.figure(figsize=(15,8))
raw_abnb.query('neighbourhood_group == "Manhattan"').groupby(['room_type'])['price'].mean().plot.bar(color='#69b3a2')
plt.xlabel('Type of Room', fontdict={'fontsize':12})
plt.ylabel('Price ($)', fontdict={'fontsize':12})
plt.xticks(rotation=45)
plt.title('Average Price by Room Type', fontdict={'fontsize':16}, pad=12)

# average price

plt.figure(figsize=(25,8))
raw_abnb.query('neighbourhood_group == "Manhattan"').groupby(['neighbourhood'])['price'].mean().plot.bar(color='#69b3a2')
plt.xlabel('Neighbourhood', fontdict={'fontsize':12})
plt.ylabel('Price ($)', fontdict={'fontsize':12})
plt.xticks(rotation=45)
plt.title('Average Price by Manhattan Neighbourhood', fontdict={'fontsize':16}, pad=12)

"""longitude', 'latitude', 'number_of_reviews',
       'reviews_per_month', 'minimum_nights', 'neighbourhood',
       'calculated_host_listings_count', 'availability_365'
"""

raw_abnb.query('neighbourhood_group == "Manhattan"').plot.scatter(x = 'latitude', y = 'price')
plt.xlabel('Latitude', fontdict={'fontsize':12})
plt.ylabel('Price ($)', fontdict={'fontsize':12})
plt.xticks(rotation=45)
plt.title('Average Price by Latitude', fontdict={'fontsize':16}, pad=12)

raw_abnb.query('neighbourhood_group == "Manhattan"').plot.scatter(x = 'longitude', y = 'price')
plt.xlabel('Longitude', fontdict={'fontsize':12})
plt.ylabel('Price ($)', fontdict={'fontsize':12})
plt.xticks(rotation=45)
plt.title('Average Price by Longitude', fontdict={'fontsize':16}, pad=12)